var Pinia=function(g,m){"use strict";let l;const R=t=>l=t,d=Symbol();function P(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}g.MutationType=void 0,(e=g.MutationType||(g.MutationType={})).direct="direct",e.patchObject="patch object",e.patchFunction="patch function";const n="undefined"!=typeof window,V=()=>{};function w(e,n,t,i=V){e.push(n);var s=()=>{var t=e.indexOf(n);-1<t&&(e.splice(t,1),i())};return!t&&m.getCurrentScope()&&m.onScopeDispose(s),s}function M(t,...e){t.slice().forEach(t=>{t(...e)})}const A=t=>t();function k(n,t){n instanceof Map&&t instanceof Map&&t.forEach((t,e)=>n.set(e,t)),n instanceof Set&&t instanceof Set&&t.forEach(n.add,n);for(const s in t){var e,i;t.hasOwnProperty(s)&&(e=t[s],i=n[s],n[s]=P(i)&&P(e)&&n.hasOwnProperty(s)&&!m.isRef(e)&&!m.isReactive(e)?k(i,e):e)}return n}const T=Symbol(),x=new WeakMap,E=Object["assign"];function y(a,t,n={},o,e,i){let s;const r=E({actions:{}},n),c={deep:!0};let u,p,f,h=[],l=[];var d=o.state.value[a];let y;function v(t){let e;u=p=!1,e="function"==typeof t?(t(o.state.value[a]),{type:g.MutationType.patchFunction,storeId:a,events:f}):(k(o.state.value[a],t),{type:g.MutationType.patchObject,payload:t,storeId:a,events:f});const n=y=Symbol();m.nextTick().then(()=>{y===n&&(u=!0)}),p=!0,M(h,e,o.state.value[a])}i||d||(m.isVue2?m.set(o.state.value,a,{}):o.state.value[a]={}),m.ref({});var $,b=i?function(){const t=n["state"],e=t?t():{};this.$patch(t=>{E(t,e)})}:V;function _(s,r){return function(){R(o);const t=Array.from(arguments),e=[],n=[];let i;M(l,{args:t,name:s,store:O,after:function(t){e.push(t)},onError:function(t){n.push(t)}});try{i=r.apply(this&&this.$id===a?this:O,t)}catch(t){throw M(n,t),t}return i instanceof Promise?i.then(t=>(M(e,t),t)).catch(t=>(M(n,t),Promise.reject(t))):(M(e,i),i)}}const j={_p:o,$id:a,$onAction:w.bind(null,l),$patch:v,$reset:b,$subscribe(e,n={}){const t=w(h,e,n.detached,()=>i()),i=s.run(()=>m.watch(()=>o.state.value[a],t=>{("sync"===n.flush?p:u)&&e({storeId:a,type:g.MutationType.direct,events:f},t)},E({},c,n)));return t},$dispose:function(){s.stop(),h=[],l=[],o._s.delete(a)}},O=(m.isVue2&&(j._r=!1),m.reactive(j)),S=(o._s.set(a,O),(o._a&&o._a.runWithContext||A)(()=>o._e.run(()=>(s=m.effectScope()).run(t))));for(const g in S){const R=S[g];if(m.isRef(R)&&(!m.isRef($=R)||!$.effect)||m.isReactive(R))i||(!d||($=R,m.isVue2?x.has($):P($)&&$.hasOwnProperty(T))||(m.isRef(R)?R.value=d[g]:k(R,d[g])),m.isVue2?m.set(o.state.value[a],g,R):o.state.value[a][g]=R);else if("function"==typeof R){const a=_(g,R);m.isVue2?m.set(S,g,a):S[g]=a,r.actions[g]=R}}return m.isVue2?Object.keys(S).forEach(t=>{m.set(O,t,S[t])}):(E(O,S),E(m.toRaw(O),S)),Object.defineProperty(O,"$state",{get:()=>o.state.value[a],set:e=>{v(t=>{E(t,e)})}}),m.isVue2&&(O._r=!0),o._p.forEach(t=>{E(O,s.run(()=>t({store:O,app:o._a,pinia:o,options:r})))}),d&&i&&n.hydrate&&n.hydrate(O.$state,d),u=!0,p=!0,O}let i="Store";function t(i,s){return Array.isArray(s)?s.reduce((t,e)=>(t[e]=function(){return i(this.$pinia)[e]},t),{}):Object.keys(s).reduce((t,n)=>(t[n]=function(){const t=i(this.$pinia),e=s[n];return"function"==typeof e?e.call(this,t):t[e]},t),{})}var e=t;return g.PiniaVuePlugin=function(t){t.mixin({beforeCreate(){const e=this.$options;if(e.pinia){const t=e.pinia;if(!this._provided){const e={};Object.defineProperty(this,"_provided",{get:()=>e,set:t=>Object.assign(e,t)})}this._provided[d]=t,this.$pinia||(this.$pinia=t),t._a=this,n&&R(t)}else!this.$pinia&&e.parent&&e.parent.$pinia&&(this.$pinia=e.parent.$pinia)},destroyed(){delete this._pStores}})},g.acceptHMRUpdate=function(t,e){return()=>{}},g.createPinia=function(){const t=m.effectScope(!0),e=t.run(()=>m.ref({}));let n=[],i=[];const s=m.markRaw({install(t){R(s),m.isVue2||((s._a=t).provide(d,s),t.config.globalProperties.$pinia=s,i.forEach(t=>n.push(t)),i=[])},use(t){return(this._a||m.isVue2?n:i).push(t),this},_p:n,_a:null,_e:t,_s:new Map,state:e});return s},g.defineStore=function(t,u,e){let p,f;const h="function"==typeof u;function n(t,e){var n=m.hasInjectionContext();if((t=t||(n?m.inject(d,null):null))&&R(t),!(t=l)._s.has(p))if(h)y(p,u,f,t);else{var i=p,s=(n=f,t);const{state:r,actions:a,getters:o}=n,c=s.state.value[i];y(i,function(){c||(m.isVue2?m.set(s.state.value,i,r?r():{}):s.state.value[i]=r?r():{});var t=m.toRefs(s.state.value[i]);return E(t,a,Object.keys(o||{}).reduce((t,e)=>(t[e]=m.markRaw(m.computed(()=>{R(s);var t=s._s.get(i);if(!m.isVue2||t._r)return o[e].call(t,t)})),t),{}))},n,s,0,!0)}return t._s.get(p)}return"string"==typeof t?(p=t,f=h?e:u):(f=t,p=t.id),n.$id=p,n},g.getActivePinia=()=>m.hasInjectionContext()&&m.inject(d)||l,g.mapActions=function(n,i){return Array.isArray(i)?i.reduce((t,e)=>(t[e]=function(...t){return n(this.$pinia)[e](...t)},t),{}):Object.keys(i).reduce((t,e)=>(t[e]=function(...t){return n(this.$pinia)[i[e]](...t)},t),{})},g.mapGetters=e,g.mapState=t,g.mapStores=function(...t){return t.reduce((t,e)=>(t[e.$id+i]=function(){return e(this.$pinia)},t),{})},g.mapWritableState=function(n,i){return Array.isArray(i)?i.reduce((t,e)=>(t[e]={get(){return n(this.$pinia)[e]},set(t){return n(this.$pinia)[e]=t}},t),{}):Object.keys(i).reduce((t,e)=>(t[e]={get(){return n(this.$pinia)[i[e]]},set(t){return n(this.$pinia)[i[e]]=t}},t),{})},g.setActivePinia=R,g.setMapStoreSuffix=function(t){i=t},g.skipHydrate=function(t){return m.isVue2?x.set(t,1)&&t:Object.defineProperty(t,T,{})},g.storeToRefs=function(t){if(m.isVue2)return m.toRefs(t);{const n={};for(const i in t=m.toRaw(t)){var e=t[i];(m.isRef(e)||m.isReactive(e))&&(n[i]=m.toRef(t,i))}return n}},g}({},VueDemi);